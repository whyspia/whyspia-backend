import type { FilterQuery } from 'mongoose'

import { EmoteModel } from '../models/emote.model'
import type { EmoteDocument } from '../models/emote.model'
import type { EmoteNoUContextQueryOptions, EmoteNouChainQueryOptions, EmoteQueryOptions, EmoteRequest, EmoteResponse } from '../types/emote.types'
import { InternalServerError } from './errors'
import { mapEmoteResponse, mapEmoteResponseWithNoUChainPreviews } from '../util/emoteUtil'
import escapeStringRegexp from 'escape-string-regexp'
import { createSymbolInDB, fetchAllSymbolsFromDB } from './symbol.service'
import { createEmoteNotifInDB } from './emote-notif.service'
import { getFrontendURL } from '../util/seoConstantsUtil'
import { EMOTE_CONTEXTS } from '../util/contextUtil'
import { getContextOfEmote } from './context.service'
import { NOTIF_TYPE } from '../models/emote-notif.model'

// at call of createEmoteInDB, bAgentDecidedSendNotifToReceiver passed in is what decides whether notif is sent out - EXCEPT for exceptions like pingppl where they are decided by the follows table - which that logic will be handled in this method
export async function createEmoteInDB(emoteData: Partial<EmoteRequest>, bAgentDecidedSendNotifToReceiver: boolean): Promise<EmoteResponse | null> {
  if (!emoteData.sentSymbols || emoteData.sentSymbols.length === 0) {
    console.error('No sentSymbols provided')
    throw new InternalServerError('No sentSymbols provided')
  }

  for (const sentSymbol of emoteData.sentSymbols) {
    // Check if sentSymbol exists
    const symbols = await fetchAllSymbolsFromDB({ search: sentSymbol } as any)
    if (symbols?.length === 0) {
      // Create the sentSymbol if it does not exist
      await createSymbolInDB({ name: sentSymbol.toLowerCase() })
    }
  }

  try {
    const emoteBuildData = {
      senderTwitterUsername: emoteData.senderTwitterUsername as string,
      receiverSymbols: emoteData.receiverSymbols as string[],
      sentSymbols: emoteData?.sentSymbols as string[],
      ...(emoteData?.createdAt ? { createdAt: emoteData.createdAt } : {}),  // this is for when creating multiple emotes at once - you set all their timestamp to exact same datetime - otherwise they will be slightly different if generated by mongoose
    }
    const emoteDoc = EmoteModel.build(emoteBuildData)
    const createdEmote = await EmoteModel.create(emoteDoc)

    const pattern = /^@?(\w){1,15}$/
    emoteData.receiverSymbols?.forEach(async (receiverSymbol) => {
      // const isReceiverAnEmoteContext = Object.values(EMOTE_CONTEXTS).includes(receiverSymbol as any)
      const isPossibleXUser = pattern.test(receiverSymbol)
      // const isPingpplContext = receiverSymbol as EMOTE_CONTEXTS === EMOTE_CONTEXTS.PINGPPL
      // const containsPingPlanAndPingOrPing = emoteData.sentSymbols?.some(symbol => 
      //   symbol.includes("PINGPLAN&PING:") || symbol.includes("PING:")
      // ) && !emoteData.sentSymbols?.some(symbol => symbol === "PINGPLAN:")
      
      // if one of receiverSymbol is X user, then do notification stuff. Otherwise, no need (although will be need for autonomous agents at some point probably)

      // tbh i dont thing agent should have this control to send notif like this, but clients i create do - so that's basically what this is
      // maybe one day people can choose to send notif with their emote, but receiver needs to opt in to even see those OR find the list of these somewhere
      const shouldWeSendNotif = bAgentDecidedSendNotifToReceiver && isPossibleXUser

      if (shouldWeSendNotif) {
        await createEmoteNotifInDB({ notifType: NOTIF_TYPE.EMOTE, notifDataID: createdEmote._id.toString(), receiverSymbol, initialNotifData: mapEmoteResponse(createdEmote) })
      }
    })

    return mapEmoteResponse(createdEmote)
  } catch (error) {
    console.error('Error occurred while creating emote in DB', error)
    throw new InternalServerError('Failed to create emote in DB')
  }

}

export async function fetchEmoteFromDB(EmoteId: string, skipContext: boolean = false): Promise<EmoteResponse | null> {
  try {
    const emoteDoc = await EmoteModel.findById(EmoteId)

    // this is to avoid recursion
    let emoteWithContext = null
    if (!skipContext) {
      const context = await getContextOfEmote(mapEmoteResponse(emoteDoc?.toObject() as any), null)
      emoteWithContext = { ...emoteDoc?.toObject(), context }
    }

    const resultEmote = skipContext ? emoteDoc?.toObject() : emoteWithContext
    
    return emoteDoc ? mapEmoteResponse(resultEmote as any) as EmoteResponse : null
  } catch (error) {
    console.error('Error occurred while fetching Emote from DB', error)
    throw new InternalServerError('Failed to fetch Emote from DB')
  }
}

// this gets pipeline passed to mongoose to get emotes of particular context. NOTE: this is not getting what that context displays on frontend - this just gets all emotes of passed in context
// pipeline is just array of objects
// goal is for this to be minimal, so it shouldnt handle sorting, pagination, etc - that can be appended to this return value tho
function getDBAggregatePipelineForContext(context: string, args: any) {
  if (context === EMOTE_CONTEXTS.NANA) {
    const removeIdentifyingEmotesFilter = {
      $match: {
        receiverSymbols: {
          // this is what filters out the additional emotes used for identifying nana context - prob not ideal tbh 
          $not: {
            $in: [
              new RegExp(escapeStringRegexp(EMOTE_CONTEXTS.NANA), 'iu'),
            ]
          }
        },
      } 
    }

    const pipeline = [
      removeIdentifyingEmotesFilter,
      // Lookup to join with the same collection to find "no u" context emotes
      {
        $lookup: {
          from: 'emotes', // Assuming the collection name is 'emotes'
          let: { emoteCreatedAt: "$createdAt", emoteId: "$_id" },
          pipeline: [
            {
              // this finds the emote that identifies if primary emote (being looped one at a time) is no u context emote. If not, i guess it filters this primary emote out?
              // more simply, i think this just filters out all non-noucontext emotes from results
              $match: {
                $expr: {
                  $and: [
                    { $eq: ["$createdAt", "$$emoteCreatedAt"] },
                    { $in: ["symbol", "$sentSymbols"] },
                    { $in: [EMOTE_CONTEXTS.NANA, "$receiverSymbols"] }
                  ]
                }
              }
            },
          ],
          as: 'nanaContextEmotes'
        }
      },
      // Filter out documents that didn't join with "nana" context emotes
      { $match: { "nanaContextEmotes.0": { $exists: true } } },
    ]

    return pipeline
  } else if (context === EMOTE_CONTEXTS.NOU) {

    const removeIdentifyingEmotesFilter = {
      $match: {
        receiverSymbols: {
          // this is what filters out the additional emotes used for identifying noucontext and replies - prob not ideal tbh 
          $not: {
            $in: [
              new RegExp(escapeStringRegexp(EMOTE_CONTEXTS.NOU), 'iu'),
              new RegExp(escapeStringRegexp(`${getFrontendURL()}/emote/`), 'iu')
            ]
          }
        },
      } 
    }

    const pipeline = [
      removeIdentifyingEmotesFilter,
      // Lookup to join with the same collection to find "no u" context emotes
      {
        $lookup: {
          from: 'emotes', // Assuming the collection name is 'emotes'
          let: { emoteCreatedAt: "$createdAt", emoteId: "$_id" },
          pipeline: [
            {
              // this finds the emote that identifies if primary emote (being looped one at a time) is no u context emote. If not, i guess it filters this primary emote out?
              // more simply, i think this just filters out all non-noucontext emotes from results
              $match: {
                $expr: {
                  $and: [
                    { $eq: ["$createdAt", "$$emoteCreatedAt"] },
                    { $in: ["symbol", "$sentSymbols"] },
                    { $in: [EMOTE_CONTEXTS.NOU, "$receiverSymbols"] }
                  ]
                }
              }
            },
          ],
          as: 'noUContextEmotes'
        }
      },
      // Filter out documents that didn't join with "no u" context emotes
      { $match: { "noUContextEmotes.0": { $exists: true } } },
    ]

    return pipeline
  }

  return null
}

export async function fetchAllEmotesFromDB(
  options: EmoteQueryOptions,
  skipContext: boolean = false
): Promise<EmoteResponse[]> {
  try {

    const { skip, limit, orderBy, senderTwitterUsername, receiverSymbols, sentSymbols, createdAt, context } = options
    const orderDirection = options.orderDirection === 'asc' ? 1 : -1

    // Sorting Options
    const sortOptions: any = {}
    sortOptions[orderBy] = orderDirection
    sortOptions._id = 1

    // Filter Options
    const filterOptions: FilterQuery<EmoteDocument>[] = []

    if (senderTwitterUsername) {
      filterOptions.push({
        $or: [
          { senderTwitterUsername: { $regex: new RegExp("^" + senderTwitterUsername + "$", 'iu') } },
        ],
      })
    }

    if (createdAt) {
      filterOptions.push({
        $or: [
          { createdAt: new Date(createdAt) },
        ],
      })
    }

    // TODO: test the crap out dis - it confuse me
    // decision: if multiple symbols in receiverSymbols, then each returned Emote must have receiverSymbols field that contains all requested. So what i mean is that it wont return Emotes with just the first receiverSymbol - it has to be ALL in the list. BUT, it also accepts extras in sentSymbols too AS LONG as it has ALL requested sentSymbols.
    if (receiverSymbols && receiverSymbols?.length > 0) {
      // filterOptions.push({
      //   $or: [
      //     { receiverSymbol: { $regex: new RegExp("^" + receiverSymbol + "$", 'iu') } },
      //   ],
      // })
      const regexOrConditions = receiverSymbols.map(symbol => ({
        receiverSymbols: { $regex: new RegExp("^" + escapeStringRegexp(symbol) + "$", 'iu') }
      }));
      filterOptions.push({
        $and: regexOrConditions,  // the AND is what enforces the decision above. OR will be different functionality
      })
    }


    // TODO: test the crap out dis - it confuse me
    // decision: if multiple symbols in sentSymbols, then each returned Emote must have sentSymbols field that contains all requested. So what i mean is that it wont return Emotes with just the first receiverSymbol - it has to be ALL in the list. BUT, it also accepts extras in sentSymbols too AS LONG as it has ALL requested sentSymbols.
    if (sentSymbols && sentSymbols?.length > 0) {
      const regexOrConditions = sentSymbols.map(sentSymbol => ({
        sentSymbols: { $regex: new RegExp("^" + escapeStringRegexp(sentSymbol) + "$", 'iu') }
      }));
      filterOptions.push({
        $and: regexOrConditions,  // the AND is what enforces the decision above. OR will be different functionality
      })
    }

    // Filter Query
    let filterQuery = {}
    if (filterOptions.length > 0) {
      filterQuery = { $and: filterOptions }
    }

    let emoteDocs: EmoteDocument[]
    if (context) {
      // used when context passed in to filter by
      const contextPipeline = getDBAggregatePipelineForContext(context, {})

      emoteDocs = await EmoteModel
        .aggregate(contextPipeline as any)
        .sort(sortOptions)
        .skip(skip)
        .limit(limit)
    } else {
      emoteDocs = await EmoteModel
        .find(filterQuery)
        .sort(sortOptions)
        .skip(skip)
        .limit(limit)
        .lean() // Use lean() to return plain JavaScript objects
    }


      // this is to avoid recursion
    let emotesWithContext = null
    if (!skipContext) {
      emotesWithContext = await Promise.all(emoteDocs?.map(async (e: any) => {
        // if you pass in context to filter by, then dont need to calculate it for each emote fetched from DB
        const calculatedContext = context ?? await getContextOfEmote(mapEmoteResponse(e as any), null)
        return { ...e, context: calculatedContext }
      }))
    }

    const resultEmotes = skipContext ? emoteDocs : emotesWithContext

    return resultEmotes?.map((doc) => mapEmoteResponse(doc) as EmoteResponse) as EmoteResponse[]
  } catch (error) {
    console.error('Error occurred while fetching all emotes from DB', error)
    throw new InternalServerError('Failed to fetch all emotes from DB')
  }
}

// get unresponded received emotes in the no u context (these conditions based on emotes sent at same timestamp as main emote)
export async function fetchUnrespondedEmotesFromDB(
  receiverOrSenderSymbol: string,
  options: EmoteNoUContextQueryOptions
): Promise<EmoteResponse[]> {
  const { skip, limit, orderBy, orderDirection, fetchSentOrReceived } = options

  const primaryUserFilter = fetchSentOrReceived === 'sent'
    ?
    {
      $match: {
        senderTwitterUsername: receiverOrSenderSymbol,
        receiverSymbols: {
          // this is what filters out the additional emotes used for identifying noucontext and replies - prob not ideal tbh 
          $not: {
            $in: [
              new RegExp(escapeStringRegexp(EMOTE_CONTEXTS.NOU), 'iu'),
              new RegExp(escapeStringRegexp(`${getFrontendURL()}/emote/`), 'iu')
            ]
          }
        },
      } 
    }
    // luckily this condition filters out the additional emotes used for identifying noucontext and replies. When fetchSentOrReceived === 'sent' - not so lucky
    : { $match: { receiverSymbols: receiverOrSenderSymbol } }

  try {
    const pipeline = [
      // Match emotes received by the user
      primaryUserFilter,
      // Lookup to join with the same collection to find "no u" context emotes
      {
        $lookup: {
          from: 'emotes', // Assuming the collection name is 'emotes'
          let: { emoteCreatedAt: "$createdAt", emoteId: "$_id" },
          pipeline: [
            {
              // this finds the emote that identifies if primary emote (being looped one at a time) is no u context emote. If not, i guess it filters this primary emote out?
              // more simply, i think this just filters out all non-noucontext emotes from results
              $match: {
                $expr: {
                  $and: [
                    { $eq: ["$createdAt", "$$emoteCreatedAt"] },
                    { $in: ["symbol", "$sentSymbols"] },
                    { $in: [EMOTE_CONTEXTS.NOU, "$receiverSymbols"] }
                  ]
                }
              }
            },
            // Check if the emote has been replied to
            {
              $lookup: {
                from: 'emotes',
                let: { emoteId: "$$emoteId" },
                pipeline: [
                  {
                    $match: {
                      $expr: {
                        $and: [
                          // TODO: i think one day could add in sender of user too as extra filter
                          { $in: ["reply", "$sentSymbols"] },
                          { $in: [{ $concat: [`${getFrontendURL()}/emote/`, { $toString: "$$emoteId" }] }, "$receiverSymbols"] }
                        ]
                      }
                    }
                  },
                ],
                as: 'replies'
              }
            },
            {
              $match: {
                // Ensure no replies exist
                $expr: { $eq: [{ $size: "$replies" }, 0] }
              }
            },
          ],
          as: 'noUContextEmotes'
        }
      },
      // Filter out documents that didn't join with "no u" context emotes
      { $match: { "noUContextEmotes.0": { $exists: true } } },
      // Apply skip and limit
      { $skip: skip },
      { $limit: limit },
      { $sort: { [orderBy]: orderDirection === 'asc' ? 1 : -1 } } as any
    ]

    const result = await EmoteModel.aggregate(pipeline)

    const emotesWithReplyChains = await Promise.all(result.map(async (emote) => {
      const orderBy = 'createdAt'
      const orderDirection = 'desc'
      // skip 1 bc otherwise the preview will start with the emote passed in (which is one displayed on frontend so dont need duplicate of it)
      const { chain, totalChainLength } = await findEmoteReplyChainInDB(emote._id, { skip: 1, limit: 2, orderBy, orderDirection }) // Adjust skip and limit as needed
      
      const context = await getContextOfEmote(mapEmoteResponse(emote as any), null)
      
      return { ...emote, chainPreview: chain, totalChainLength, context }
    }))

    // Assuming you need to map the results to your EmoteResponse format
    return emotesWithReplyChains.map(mapEmoteResponseWithNoUChainPreviews) as EmoteResponse[]
  } catch (error) {
    console.error('Error occurred while fetching unresponded emotes using aggregation', error)
    throw new InternalServerError('Failed to fetch unresponded emotes')
  }
}

// take in emote and if it is a reply, keep iterating backwards to find all prior replies
// a reply is identified by a separate emote DB record with same createdAt as emote replied to
export async function findEmoteReplyChainInDB(emoteId: string, options: EmoteNouChainQueryOptions): Promise<{ chain: EmoteResponse[], totalChainLength: number }> {
  let currentEmote = await EmoteModel.findById(emoteId) as any
  if (!currentEmote) {
    throw new Error('Emote not found')
  }

  const { skip, limit, orderBy, orderDirection, } = options

  const chain: any[] = [mapEmoteResponse({ ...currentEmote.toObject(), context: EMOTE_CONTEXTS.NOU })] as any
  let searching = true
  let totalChainLength = 1 // Initialize total length with the first emote

  while (searching) {
    const createdAt = currentEmote.createdAt

    // Find the emote that indicates a reply, by matching createdAt and containing a URL in receiverSymbols
    const replyIndicatorEmote = await EmoteModel.findOne({
      createdAt: createdAt,
      sentSymbols: 'reply'
    })

    if (!replyIndicatorEmote) {
      searching = false // No reply indicator found, end of chain
      break
    }

    // Extract the replied-to emote ID from the reply indicator
    const repliedToUrl = replyIndicatorEmote.receiverSymbols.find(symbol => symbol.startsWith(`${getFrontendURL()}/emote/`));
    const repliedToEmoteId = repliedToUrl?.split('/').pop()

    if (!repliedToEmoteId) {
      searching = false // Malformed URL or end of chain
      break
    }

    // Find the emote that was replied to
    const repliedToEmote = await EmoteModel.findById(repliedToEmoteId)

    if (repliedToEmote) {
      chain.unshift(mapEmoteResponse({ ...repliedToEmote.toObject(), context: EMOTE_CONTEXTS.NOU } as any)) // Prepend to maintain order
      currentEmote = repliedToEmote // Set this as the current emote for the next iteration
      totalChainLength++ // Increment total length
    } else {
      searching = false // No further replies found
    }
  }

  // Sort the chain based on orderBy and orderDirection
  // this defs works for timestamp (and i think any numerical values), but otherwise wont work
  chain.sort((a, b) => {
    if (options.orderDirection === 'asc') {
        return a[options.orderBy] > b[options.orderBy] ? 1 : -1;
    } else {
        return a[options.orderBy] < b[options.orderBy] ? 1 : -1;
    }
  })

  // Apply skip and limit
  const paginatedChain = chain.slice(skip, skip + limit)

  return { chain: paginatedChain, totalChainLength }
}

// export async function updateEmoteInDB(EmoteId: string, updatedData: Partial<EmoteResponse>): Promise<EmoteResponse | null> {
//   try {
//     const updatedEmoteDoc = await EmoteModel.findByIdAndUpdate(EmoteId, updatedData, { new: true })
//     return updatedEmoteDoc ? updatedEmoteDoc.toObject() : null
//   } catch (error) {
//     console.error('Error occurred while updating Emote in DB', error)
//     throw new InternalServerError('Failed to update Emote in DB')
//   }
// }

export async function deleteEmoteInDB(emoteId: string): Promise<void> {
  try {
    await EmoteModel.findByIdAndDelete(emoteId)
  } catch (error) {
    console.error('Error occurred while deleting emote from DB', error)
    throw new InternalServerError('Failed to delete emote from DB')
  }
}
